extends ../layout

block script
    script(type="module").
        import Quill from "quill";
        import QuillCursors from "quill-cursors";

        import * as Y from "yjs";
        import { QuillBinding } from "y-quill";
        import { WebsocketProvider } from "y-websocket";

        Quill.register("modules/cursors", QuillCursors);

        function createQuill({ id, toolbarId, placeholder, note, onUpdate, onImageUpload }) {
            const quill = new Quill(`#${id}`, {
                modules: {
                    cursors: true,
                    toolbar: `#${toolbarId}`,
                    history: { userOnly: true }
                }
            });

            quill.root.setAttribute("placeholder", placeholder);

            quill.getModule("toolbar").addHandler("image", () => {
                const input = document.createElement("input");

                input.setAttribute("type", "file");
                input.setAttribute("accept", "image/*");

                input.click();

                input.onchange = async () => {
                    const file = input.files[0];
                    const filePath = await onImageUpload(file);

                    if (filePath) {
                        const range = quill.getSelection();
                        quill.insertEmbed(range.index, "image", filePath);
                        onUpdate(quill.getContents());  // Updates the note after embedding the image
                    }
                }
            });

            if (note.shared_id || note.shared) {
                const ydoc = new Y.Doc();
                const provider = new WebsocketProvider(
                    "ws://localhost:4321", `sn_${note.id}`, ydoc
                );
                const ytext = ydoc.getText("quill");

                ytext.observe(() => {
                    if (note.shared || note.permission === "edit") {
                        onUpdate(ytext.toDelta());
                    }
                });

                provider.once("synced", () => {
                    if (ytext.length === 0) {
                        ytext.applyDelta(note.content);
                    }
                });

                if (note.permission === "read") {
                    quill.enable(false);
                }

                new QuillBinding(ytext, quill);
            } else {
                quill.on("text-change", (delta, oldDelta, source) => {
                    if (source === "user") {
                        onUpdate(quill.getContents().ops);
                    }
                });

                quill.setContents(note.content);
            }

            return quill;
        }

        Alpine.data("editor", function () {
            return {
                unlocked: false,

                async init() {
                    if (this.$store.notes.list.length === 0) {
                        await this.$store.notes.fetch();
                    }

                    const id = Number(this.$params.id);
                    this.note = this.$store.notes.get(id);

                    if (!this.note) {
                        setTimeout(() => this.$router.navigate("/"));
                        notyf.error("The note you're looking for isn't here, but we believe in you!");
                    } else if (this.note.password) {
                        // Next tick in order to show the password prompt properly
                        this.$nextTick(() => this.$dispatch("prompt-unlock", {
                            noteId: this.note.id,
                            onSuccess: () => this.createEditor(),
                            onClose: () => {
                                if (!this.unlocked) {
                                    this.$router.navigate("/");
                                }
                            }
                        }));
                    } else {
                        this.createEditor();
                    }
                },

                createEditor() {
                    const quill = createQuill({
                        id: "editor",
                        toolbarId: "editor-toolbar",
                        placeholder: "Write something legendary! Or just your grocery list...",
                        note: this.note,
                        onUpdate: (content) => this.$dispatch("update-note", content),
                        onImageUpload: async (file) => {
                            const path = await uploadImage(file);
                            return path ? `${API_URL}/api/${path}` : null;
                        }
                    });

                    this.$el.querySelector(".ql-editor").className
                        = `ql-editor ${this.$store.notes.colors[this.note.note_color]}`;

                    this.unlocked = true;

                    quill.focus();
                },

                get noteExists() {
                    return this.note !== undefined;
                }
            }
        });

block header-left
    a.btn-icon(type="button", x-ref="closeEditor", href="/")
        i.fa.fa-arrow-left

block content
    #editor-container.flex-1.flex(
        x-data="editor",
        @update-note.debounce.2s=`
            $store.notes.update($params.id, {
                content: JSON.stringify($event.detail)
            })
        `
    )
        .flex.flex-col.gap-4.w-full.max-w-4xl.p-4.mx-auto(x-show="unlocked")
            #editor-toolbar.flex.flex-wrap.items-center.gap-y-2.p-2.mx-auto
                select.ql-header.form-input(class="!w-40 !mt-0")
                    each h in [1, 2, 3]
                        option(value=h) Heading #{h}
                    option(selected) Body

                .px-2

                -
                    const formats = {
                        bold: {}, italic: {}, underline: {},
                        strike: { icon: "strikethrough" }
                    }

                each [format, options] of Object.entries(formats)
                    button.btn-icon(type="button", class=`ql-${format}`)
                        i.fa(class=`fa-${options.icon || format}`)

                .px-2

                -
                    const aligns = {
                        "": { icon: "left" },
                        justify: {}, center: {}, right: {}
                    }

                each [align, options] of Object.entries(aligns)
                    button.ql-align.btn-icon(type="button", value=align)
                        i.fa(class=`fa-align-${options.icon || align}`)

                .px-2

                button.ql-image.btn-icon(type="button")
                    i.fa.fa-image

                template(x-if="noteExists && !note.shared_id")
                    .px-2
                        +note-more-options

            #note-title
                input.form-input.text-2xl.font-bold.p-5(
                    type="text",
                    :value="noteExists ? note.title : ''",
                    placeholder="Note title",
                    class="!bg-gray-300 dark:!bg-gray-900",
                    @input.debounce.2s=`$store.notes.update(
                        $params.id, { title: $el.value }
                    )`
                )

            #editor(
                class="!overflow-visible",
                :style="`font-size: ${noteExists ? note.font_size : '1rem'}`"
            )

        .flex-1.flex.justify-center.items-center(x-show="!unlocked")
            .spinner.scale-200